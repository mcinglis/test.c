// test.h

// Copyright (C) 2013  Malcolm Inglis
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or (at
// your option) any later version.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
// General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.


#ifndef INCLUDED_TEST_H
#define INCLUDED_TEST_H


#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

#include <macromap.h/macromap.h>        // MACROMAP


// An assertion is a boolean expression and its evaluation. An assertion
// may be identified so that it's easier to tell when and where it failed.
// This is useful when multiple assertions are made with the same
// expression, but different values.
typedef struct TestAssertion {
    char const * expr;
    bool result;
    char const * id_expr;
    int id;
} TestAssertion;


// A test is a named function that generates an array of assertions. A
// test is considered to pass if all these assertions are true.
typedef struct Test {

    // Used for displaying and naming the results of the test.
    char const * name;

    // Returns a dynamically-allocated array of assertions terminated by
    // an assertion with a null `expr` field. It may also return null to
    // signal that it doesn't make any assertions: this is commonly used
    // with `TEST_REQUIRE`, or tests that fail by prompting a run-time
    // error like a segmentation fault.
    TestAssertion * ( *func )( void * data );

    // If non-null, this is executed to generate the `data` argument to
    // pass to the test's `func` field.
    void * ( *before )( void );

    // If non-null, this is executed after calling the test's `func`,
    // and is passed the `data` generated by `before` and possibly
    // modified by `func`.
    void ( *after )( void * data );

} Test;


// Represents the results of running a set of tests.
typedef struct TestResults {
    int passed;
    int failed;
} TestResults;


// Copies an array of assertions onto the heap.
TestAssertion * test_assertions_alloc( TestAssertion const * assertions );


// Evaluates to a `TestAssertion` literal with the given expression.
#define TEST_ASSERTION( EXPR ) { .expr = #EXPR, .result = ( EXPR ) }


// The end of an assertion array is an assertion with a null `expr`.
#define TEST_ASSERTIONS_END { .expr = NULL }


// Takes a variable number of boolean expressions, and returns a pointer
// to an array of assertions on the heap, with each assertion
// corresponding to a given expression. Note that because this uses
// `MACROMAP`, this can't take more than 128 arguments, and no argument
// can begin with more than four parentheses.
#define test_assert( ... ) \
    test_assertions_alloc( ( TestAssertion[] ){ \
        MACROMAP( TEST_ASSERTIONS_EL, __VA_ARGS__ ) \
        TEST_ASSERTIONS_END \
    } )

// Prefixes a comma to separate each element of the array.
#define TEST_ASSERTIONS_EL( EXPR ) TEST_ASSERTION( EXPR ),


// If the given boolean expression evaluates to false, this causes the
// containing function to return that expression as an assertion (which
// will be false), identified with the given `ID` expression if that
// expression is not a literal "0". This provides an easy way to assert
// things in a loop.
#define TEST_REQUIRE( EXPR, ID ) { \
    bool result = ( EXPR ); \
    if ( !result ) { \
        TestAssertion ta = TEST_ASSERTION( EXPR ); \
        if ( strcmp( #ID, "0" ) != 0 ) { \
            ta.id = ID; \
            ta.id_expr = #ID; \
        } \
        return test_assertions_alloc( ( TestAssertion[] ){ \
            ta, TEST_ASSERTIONS_END \
        } ); \
    } \
}


// Evaluates to a `Test` literal with the given test function
// expression, and named with the stringification of that expression.
#define TEST( FUNC ) { .func = FUNC, .name = #FUNC }

// Evaluates to a `Test` literal with the given arguments as fields,
// and `name` as a stringfication of the `FUNC` expression.
#define TEST_FIX( BEFORE, AFTER, FUNC ) \
    { .func = FUNC, .name = #FUNC, .before = BEFORE, .after = AFTER }


// The end of a test array is a test with a null `func`.
#define TESTS_END { .func = NULL }


// Takes a variable number of test function expressions, and evaluates
// to a `Test[]` literal with each test named as a stringification of
// its corresponding function expression. Note that because this uses
// `MACROMAP`, this can't take more than 128 expressions, and no
// expression can begin with more than 4 nested parentheses.
#define TESTS( ... ) { MACROMAP( TESTS_EL, __VA_ARGS__ ) TESTS_END }

// Prefixes a comma to separate each element of the array.
#define TESTS_EL( FUNC ) TEST( FUNC ),


// Similar to `TESTS`, but also takes two function expressions to set as
// the `before` and `after` fields of each of the tests constructed
// expressions. Note that because this uses `MACROMAP3`, this can't take
// more than 128 expressions, and no argument can begin with more than 4
// nested parentheses.
#define TESTS_FIX( BEFORE, AFTER, ... ) \
    { MACROMAP3( TESTS_FIX_EL, BEFORE, AFTER, __VA_ARGS__ ) \
      TESTS_END }

// Prefixes a comma to separate each element of the array.
#define TESTS_FIX_EL( BEFORE, AFTER, FUNC ) \
    TEST_FIX( BEFORE, AFTER, FUNC ),


// Runs each test in the `tests` array, and prints the results to
// stdout, with `name` printed as the name of the set of tests.
TestResults tests_run( char const * name, Test const * tests );


#endif // ifndef INCLUDED_TEST_H

